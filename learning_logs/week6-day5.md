## 学习简报 - 2025年7月4日 (JS底层原理 & React启航)

**总学习时长 (此期间合计)：** 约 4 小时

**学习课程/内容：** 《你不知道的JS (上卷)》- 作用域与`this` & React 基础入门

**核心任务：完成对JavaScript底层核心原理的深度探索，并以此为坚实基础，无缝过渡到React框架的学习，掌握其现代化开发环境、核心JSX语法及组件化思想，开启实战项目之旅。**

**完成内容与学习点：**

### **第一部分：JavaScript 理论基石深度探索 (为学习框架铺路)**

在进入任何现代前端框架的学习之前，我选择先回归本源，投入大量时间系统性地学习和巩固了JavaScript的底层工作机制。我坚信，只有理解了语言的“为什么”，才能更好地运用基于它的“工具”。

#### **1. 揭秘“黑盒”：JS 引擎的编译原理**
*   **核心认知转变：** 彻底打破了“JS是一门解释型语言”的传统印象，明确了它实际上是一门在执行前几微秒进行编译的**即时编译 (JIT) 语言**。这解释了为何JS能进行性能优化，也为理解作用域的工作方式打下了基础。
*   **编译三步走流程：**
    1.  **分词/词法分析 (Tokenizing/Lexing):** 深入理解了代码 `var a = 2;` 是如何被分解成 `var`, `a`, `=`, `2`, `;` 这些有意义的**词法单元 (Token)** 的过程。
    2.  **解析/语法分析 (Parsing):** 学习了 Token 流如何被转换成一个具有层级结构的**抽象语法树 (AST)**。这是整个编译过程的核心数据结构。
    3.  **代码生成 (Code Generation):** 了解了 AST 最终如何被 JS 引擎转换为一组可执行的机器指令。
*   **AST 的深远影响：** 认识到 AST 不仅仅是一个理论概念，它更是 **ESLint** (语法检查)、**Prettier** (代码格式化)、**Babel** (语法转换)、**TypeScript** (类型检查) 等一系列现代前端工具能够工作的**核心基石**。

#### **2. 引擎、编译器与作用域的“铁三角”协作模型**
*   通过生动的角色扮演类比，我理清了这三者的关系：
    *   **引擎 (Engine):** 作为**总导演**，统筹全局，负责从头到尾的编译和执行。
    *   **编译器 (Compiler):** 作为**剧本分析师**，在引擎需要时，负责词法分析、语法分析和代码生成。
    *   **作用域 (Scope):** 作为**场务/道具管理员**，维护着一套严格的规则，管理着所有已声明的标识符（变量、函数），并对引擎的查询请求作出响应。

#### **3. LHS 与 RHS 查询：变量访问的两种视角 (重点)**
*   **本质区分：** 这是本次理论学习的最大收获之一。
    > [!IMPORTANT]
    > *   **LHS (Left-Hand Side) 查询：** 发生在为变量**赋值**时。它的目的是找到那个**变量容器本身（内存地址）**，以便把值放进去。例如 `a = 2;` 中的 `a`。
    > *   **RHS (Right-Hand Side) 查询：** 发生在需要**获取变量的值**时。它的目的是找到变量容器，然后**取出里面的东西**。例如 `console.log(a);` 中的 `a`。
*   **查询失败的后果辨析：**
    *   **RHS 查询失败**（找不到变量的值），作用域会到顶层（全局作用域）都找不到，最终引擎会抛出一个非常明确的 **`ReferenceError`**。
    *   **LHS 查询失败**（找不到变量容器来赋值），其行为取决于是否在**严格模式 (Strict Mode)** 下：
        *   **非严格模式：** 全局作用域这个“热心的管理员”会说：“没找到？那我帮你创建一个吧！”，于是在全局创建了一个同名变量。这是JS中意外产生全局变量的根源。
        *   **严格模式：** 全局作用域会拒绝创建，并同样抛出 **`ReferenceError`**。
*   **`TypeError` vs. `ReferenceError`：** 通过这个模型，我彻底分清了这两个常见错误。`ReferenceError` 是作用域查询层面的失败（“人没找到”），而 `TypeError` 则是查询成功后，对这个值的操作类型不匹配（“事情做错了”）。

#### **4. `this` 关键字的底层绑定规则**
*   **核心认知颠覆：** 建立了“`this` 的指向与函数声明的位置无关，只与**函数的调用位置和调用方式**有关”的正确认知。它不是指向函数或其作用域，而是在函数执行时，由**执行上下文**动态提供的一个属性。
*   **显式绑定三兄弟 (`call`/`apply`/`bind`):**
    *   **目的：** 掌握了这三个API是用于**强制指定函数执行时的`this`**，是解决“方法借用”（如数组方法用于类数组对象）和“回调函数`this`丢失”（如 `setTimeout` 中的回调）两大经典场景的利器。
    *   **精细辨析：**
        *   `.call(thisArg, arg1, ...)`: **立即执行**，参数**逐个罗列**。
        *   `.apply(thisArg, [argsArray])`:** 立即执行**，参数以**数组形式**传递。
        *   `.bind(thisArg, arg1, ...)`: **不立即执行**，而是**返回一个`this`被永久绑定的新函数**，非常适用于事件处理和需要延迟执行的场景。

---

### **第二部分：React 框架入门与现代化工程实践**

带着对 JS 底层的深刻理解，我正式开启了 React 学习，并从一开始就力求采用最现代、最高效的工程化实践。

#### **5. 开发环境搭建与关键决策 (`CRA` -> `Vite`)**
*   **敏锐的技术嗅觉与主动决策：** 在初次尝试使用课程推荐的 `create-react-app` (CRA) 时，我没有盲从，而是注意到了终端输出中一个关键的警告信息：**`create-react-app is deprecated`**。这促使我立即去查阅资料，了解到 CRA 已不再是官方首推的工具。基于对开发效率和技术趋势的考量，我果断放弃了CRA，主动选择了以其极速冷启动和热更新闻名的 **Vite** 作为我的项目构建工具。这次决策让我从学习的第一天起，就站在了现代前端工程化的前沿。

#### **6. Vite 项目工作流与启动流程深度剖析**
*   **从 `npm`到 `pnpm`:** 在后续的学习中，为了追求更高的安装效率和更优的磁盘空间利用率，我主动学习并切换使用了 `pnpm`，理解了其通过符号链接节省空间的原理。
*   **启动链路的全程追踪：** 我彻底理清了在 Vite 环境下，一个 React 应用是如何“活”起来的：
    1.  浏览器首先请求并接收位于**项目根目录**的 `index.html`，这是应用的“骨架”。
    2.  浏览器解析 HTML，发现 `<script type="module" src="/src/main.jsx">`，于是向服务器请求这个 JS 入口文件。
    3.  Vite 开发服务器**按需编译** `main.jsx`（将 JSX 转换为 JS），并返回给浏览器。
    4.  浏览器执行 `main.jsx` 中的 `ReactDOM.createRoot(document.getElementById('root')).render(<App />)`，将 React 组件树正式“挂载”到 `index.html` 预留的 `<div id="root">` 节点上。
        这个过程让我深刻理解了 Vite 基于原生 ES Module 的高效工作模式。

#### **7. JSX 核心语法与组件化思想入门**
*   **JSX 本质与动态能力：** 我不仅掌握了 JSX 的基础语法，如**单一根元素**（并学会使用 `<></>` Fragment 避免不必要的 `div`）和**标签必须闭合**，更重要的是，我深入理解了它的动态能力。通过 `{}`，我们可以在 JSX 中无缝嵌入任何 JavaScript **表达式**。
*   **表达式 vs. 语句 (关键辨析):** 我主动探究了为何 `if...else` 这样的**语句 (Statement)** 不能直接用于 `{}` 中，而 `a + b` 或三元运算符这样的**表达式 (Expression)** 却可以。这个辨析让我对 React 的声明式UI和函数式编程思想有了更深的体会。
*   **组件化思想的启蒙：** 通过对比 `App.jsx`（一个定义组件的JS模块/蓝图）和 `<App />`（一个在JSX中声明要使用该组件实例的语法），我初步建立了 React 组件化开发的思维模型。

---
### 🤔 思考与心得

*   **自底向上的学习，事半功倍：** 先花时间打牢 JS 底层原理的地基，再来学习 React 这个上层框架，让我感觉豁然开朗。很多 React 的“规则”和“设计”，其实都源于对 JavaScript 语言特性的深刻理解和巧妙运用。
*   **保持批判性思维，拥抱变化：** 对一个 `deprecated` 警告的追问，引导我走向了 Vite 这个更现代的工具。这让我意识到，在技术飞速发展的今天，保持好奇心和主动学习的能力，比单纯地掌握某个工具更重要。
*   **理论联系实践，形成闭环：** 将学到的 `this` 知识应用到“百度外卖”项目的事件回调中，将 JSX 知识应用到“B站评论”的列表渲染中，这种“学-用-思”的闭环，是知识内化的最佳途径。

---
### 🚀 后续计划

*   **继续看书，深入挖掘 this 的问题：** 后续专门整理出一个文档来展示对 this 问题的理解。
*   **继续深入 React Hooks：** 系统性地学习 `useEffect`, `useContext`, `useRef` 等核心 Hooks，探索 React 如何处理副作用和复杂状态。
*   **持续的工程化实践：** 在后续项目中，继续使用 `pnpm`，并探索使用 Vercel 等平台进行自动化部署，打通从开发到上线的完整链路（晚期）。