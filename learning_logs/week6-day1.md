## 学习简报 - 2024年06月30日

**总学习时长 (此期间合计)：** 约 8 小时

**学习课程/内容：** 黑马程序员 - 《前端JavaScript入门到精通全套视频教程》 - JS 进阶

**核心任务：冲刺学习“现代JS必备包”，深入理解作用域、解构、箭头函数、高阶数组方法，并开始系统学习JavaScript面向对象编程（OOP）与原型核心机制。**

**完成内容与学习点：**

### **第一部分：JS 进阶 - 现代语法与核心概念**

1.  **作用域与垃圾回收 (理论深化):**
    *   **作用域链:** 再次巩固了变量查找遵循“由内向外”的词法作用域链。
    *   **垃圾回收 (GC):**
        > [!IMPORTANT]
        > 理解了JS内存管理的自动机制。重点区分了两种核心算法：
        > 1.  **引用计数:** 原理简单，但无法解决**循环引用**导致的内存泄漏。
        > 2.  **标记-清除 (现代主流):** 通过从“根”对象（如`window`）出发，标记所有**可达**对象，然后回收不可达对象，能有效解决循环引用问题。

2.  **闭包 (Closure):**
    *   **核心定义:** 闭包 = **内层函数 + 外层函数的变量引用**。
    *   **核心作用:** 实现**数据私有/封装**。通过将变量“封闭”在外层函数中，只返回可操作该变量的内层函数作为“公共API”，从而保护内部数据不被外部直接修改。
    *   **潜在风险:** 了解了闭包可能导致的**内存泄漏**问题，以及通过及时解除引用（如设为`null`）来规避。

3.  **变量提升 (Hoisting):**
    *   **`var` 的缺陷:** 明确了变量提升仅存在于 `var` 和函数声明中，其“只提升声明，不提升赋值”的特性是JS的一个历史缺陷。
    *   **`let`/`const` 的优势:** 理解了 `let` 和 `const` 通过引入**暂时性死区 (TDZ)**，没有变量提升，强制了“先声明后使用”的规范。

4.  **函数参数进阶:**
    *   **`arguments` (伪数组):** 了解其是函数内置的、包含所有实参的**类数组对象**，没有数组的`map`/`filter`等方法。
    *   **剩余参数 (`...args`) (推荐):** 掌握了使用 `...` 来收集多余参数，它会得到一个**真数组**，可以方便地使用所有数组方法。

5.  **解构赋值 (Destructuring):**
    *   **数组解构:** `const [a, b] = arr`，按**位置**匹配，并掌握了默认值、剩余参数、忽略赋值等技巧。
    *   **对象解构 (重点):** `const { name, age } = obj`，按**属性名**匹配，并掌握了重命名 (`name: newName`)和多级解构。

6.  **展开运算符 (`...`):**
    *   **作用:** 将数组或可迭代对象**展开**成独立的元素序列。
    *   **核心应用:** `Math.max(...arr)` 求最值；`[...arr1, ...arr2]` 合并数组；`[...pseudoArr]` 将伪数组转为真数组。

### **第二部分：JS 进阶 - 面向对象与原型**

7.  **编程思想对比:**
    *   清晰地区分了**面向过程**（关注步骤，如菜谱）和**面向对象**（关注对象分工，如餐厅厨房）两种编程思想的优劣与适用场景。
    *   掌握了OOP的三大特性：**封装、继承、多态**。

8.  **构造函数 (Constructor):**
    *   **核心目的:** 作为对象模板，用于**批量创建**结构相同的实例对象。
    *   **`new` 关键字实例化过程 (四步):**
        1. 创建空对象。
        2. `this` 指向新对象。
        3. 执行构造函数代码。
        4. 返回新对象。
    *   **成员区分:**
        *   **实例成员:** 在构造函数内部通过 **`this.xxx`** 定义，每个实例独有一份。
        *   **静态成员:** 直接在**构造函数上**定义（`Constructor.xxx`），由构造函数直接调用，所有实例共享。

9.  **原型 (Prototype - 重中之重):**
    *   **核心目的:** 解决构造函数模式中，**方法**被重复创建导致的内存浪费问题，实现**方法共享**。
    *   **黄金法则:**
        > [!TIP]
        > **“属性放构造，方法放原型”**: 将每个实例**独有**的属性放在构造函数中通过`this`定义；将所有实例需要**共享**的方法，定义在构造函数的 **`.prototype`** 对象上。
    *   **`this` 指向:** 深刻理解了无论是构造函数还是原型方法中，`this` 都指向**调用它的那个实例对象**。
    *   **原型扩展:** 实践了通过 `Array.prototype.xxx` 给内置对象扩展方法，并理解了这种做法（污染全局原型）在生产项目中的风险。

### 🤔 思考与心得

*   **从“怎么用”到“为什么”:** 今天学习的内容理论性极强，重点从API的使用转向了对JS底层机制（如GC、作用域、原型）的理解，这是技术深度提升的关键。
*   **现代写法的优势:** 通过学习解构、箭头函数、剩余参数等，深刻体会到ES6+语法不仅是“语法糖”，更是为了解决旧有语法的缺陷和不足，能让代码更简洁、更健壮。
*   **思想指导实践:** 对面向对象思想的理解，让自己明白了构造函数和原型“各司其职”的深层原因，而不仅仅是记住一个开发模式。

---
### 🚀 后续计划

*   **首要任务:** 深入理解**原型链**，完成`__proto__`, `prototype`, `constructor`三者关系的闭环。
*   **下一步:** 学习 ES6 的 `class` 语法糖，了解它是如何简化面向对象写法的。
*   继续攻克“现代JS必备包”中的 **Promise** 与 **`async/await`**。
