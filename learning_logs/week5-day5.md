## 学习简报 - 2024年06月27日

**总学习时长 (此期间合计)：** 约 7 小时

**学习课程/内容：** 黑马程序员 - 《前端JavaScript入门到精通全套视频教程》 - Web APIs (DOM事件, BOM, 节点操作) & JS 核心

**核心任务：完成大型综合案例，巩固DOM事件高级应用，并深入学习BOM对象与JS核心执行机制。**

**完成内容与学习点：**

### **第一部分：DOM 事件与综合案例实践 (重点)**

1.  **待办任务实践 - “元素淡出后彻底消失”:**
    *   **核心方案:** 完美结合了 CSS `transition` 和 JavaScript `transitionend` 事件，解决了 `display: none` 无法参与动画的问题。
    *   **实现流程:**
        1.  **JS 启动:** 通过 `element.classList.add('hiding')` 触发 CSS 中预设的 `opacity` 过渡。
        2.  **JS 监听:** 使用 `element.addEventListener('transitionend', callback, { once: true })` 监听动画结束。
        3.  **JS 收尾:** 在回调中，通过 `element.style.display = 'none'` 彻底移除元素。
    *   **学习价值:** 深刻理解了如何**利用 JS 事件模型来编排和协调 CSS 动画**，这是现代前端交互开发的基础模式。

2.  **大型综合案例 - “电梯导航” (全部完成):**
    *   **需求分析与分解:**
        > [!TIP]
        > 在动手前，对复杂需求进行了清晰的模块化拆解（显隐、点击跳转、滚动高亮、代码封装），这种**自顶向下、逐步求精**的分析方法是解决复杂问题的关键。
    *   **滚动时导航高亮 (核心逻辑):**
        *   对比并实践了两种实现思路：
            *   **`if-else if` 链:** 逻辑直观，适用于模块固定的页面。
            *   **`for` 循环动态判断 (更优):** 通过遍历所有内容区 `section`，找出**最后一个**满足 `scrollTop >= section.offsetTop` 的元素来确定当前激活索引。这种方式**代码简洁、可扩展性强**，无需因内容增删而修改JS。
    *   **工程化思维:** 整个模块被包裹在 **IIFE (自执行函数)** 中，有效避免了全局变量污染。

### **第二部分：JavaScript 核心运行机制**

3.  **JS 执行机制 (Event Loop - 重点):**
    *   **单线程模型:** 明确了 JS 是**单线程**语言，耗时任务会**阻塞**页面渲染。
    *   **同步与异步:**
        *   **同步任务 (Synchronous):** 在**主线程**上执行，存放在**执行栈 (Execution Stack)**。
        *   **异步任务 (Asynchronous):** 交由浏览器API处理，其**回调函数**完成后被放入**任务队列 (Task Queue)**。
    *   **事件循环 (Event Loop) 核心三步:**
        > [!IMPORTANT]
        > 1.  首先执行**执行栈**中的所有同步任务。
        > 2.  当执行栈为空时，去**任务队列**中读取第一个任务。
        > 3.  将被读取的任务（回调函数）推入执行栈中执行，然后重复此过程。
    *   **理解异步的本质:** 通过该模型，深刻理解了为什么 `setTimeout(fn, 0)` 也会在所有同步代码之后执行。

### **第三部分：Web APIs - BOM & 节点操作**

4.  **BOM (浏览器对象模型) 核心对象:**
    *   **`window` 对象:** 理解其作为BOM顶层对象和JS全局对象的双重身份。
    *   **`location` 对象:**
        *   **属性:** 掌握了 `.href` (跳转), `.search` (查询参数), `.hash` (锚点) 的读写。
        *   **方法:** `location.reload()` (刷新)。
    *   **`history` 对象:** 掌握了 `history.back()`, `.forward()`, `.go()` 用于操作浏览器历史。
    *   **`navigator` 对象:** 了解了通过 `.userAgent` 进行浏览器和平台信息检测。

5.  **定时器函数 (再复习):**
    *   **`setTimeout` (延时函数):** **执行一次**，通过 `clearTimeout()` 清除。
    *   **`setInterval` (间歇函数):** **重复执行**，通过 `clearInterval()` 清除。
    *   明确了两者的核心区别在于**执行次数**。

6.  **DOM 节点操作 (增/删/改/查/克隆):**
    *   **关系查找 (重点):**
        *   **父级:** `element.parentNode`。
        *   **子级:** **`element.children` (推荐)** 返回只含元素节点的 `HTMLCollection`，区别于返回所有节点的 `childNodes`。
        *   **兄弟:** **`element.nextElementSibling` / `.previousElementSibling` (推荐)**，以避免选中无用的空白文本节点。
    *   **增加节点:** 掌握了 `document.createElement()` + `parentElement.appendChild()` / `.insertBefore()` 的标准流程。
    *   **删除节点:** 掌握了**必须通过父元素**调用 `parentElement.removeChild(child)` 的标准方式，并了解了更现代的 `element.remove()` 方法。
    *   **克隆节点 (`.cloneNode(deep)`):**
        *   **深/浅克隆:** 明确了 `deep` 参数为 `true` (深克隆) 会复制所有后代节点，为 `false` (浅克隆, 默认) 只复制节点本身。
        *   **注意事项:** `cloneNode()` **不会复制**通过JS绑定的事件监听器。
    *   **隐藏 vs. 删除 (本质区别):**
        > `display: none` (隐藏) 的节点**依然存在于DOM树中**；而 `removeChild()` (删除) 的节点则**彻底从DOM树中移除**。

7.  **本地存储 (Web Storage):**
    *   **`localStorage` vs `sessionStorage`:**
        *   **生命周期:** 前者**永久**，后者**会话级** (窗口关闭即销毁)。
        *   **作用域:** 前者**同源跨窗口共享**，后者**窗口隔离**。
    *   **核心要点 (极其重要):**
        *   本地存储只能存储**字符串**。
        *   存储复杂数据（对象/数组）时，必须先用 **`JSON.stringify()`** 序列化，读取时再用 **`JSON.parse()`** 反序列化。

8.  **现代数据渲染技巧 (`map` + `join`):**
    *   **核心思路:** 学习并实践了使用 `array.map()` 将数据数组映射成一个HTML字符串数组，再用 `.join('')` 将其连接成一个大字符串，最后通过 `.innerHTML` 整体渲染。
    *   **思维转变:** 这是从“命令式” (`for`循环拼接) 向“**声明式**”编程思维的转变，代码更简洁、更函数式，也是React/Vue等现代框架渲染列表的底层思想。

---

### 🤔 思考与心得

*   **需求分析的重要性:** 在做“电梯导航”时，深刻体会到“自顶向下、逐步求精”的分析方法，能让复杂问题变得条理清晰，是高效开发的前提。
*   **代码的健壮性:** 在实践中，开始主动运用**可选链 (`?.`)**、**IIFE**、**事件委托**、**输入验证 (`.trim()`)** 等技巧，代码质量和专业性得到了显著提升。
*   **底层原理的价值:** 对JS事件循环的理解，是后续掌握异步编程（Promise/async）的基石。对DOM节点操作原理的掌握，是理解现代框架为何高效的钥匙。

---
### 🚀 后续计划

*   **首要任务:** 开始系统学习“现代JS必备包”，为进入React/Vue框架学习做好充分准备。
    *   箭头函数
    *   解构赋值
    *   数组的高阶方法 (`map`, `filter`, `reduce` 等)
    *   Promise 与 `async/await`
